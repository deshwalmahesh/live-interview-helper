<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Interview Helper</title>
    <link rel="icon" type="image/x-icon" href="/icon.png">
    <link rel="icon" href="data:,">
    <style>
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 70px;
            background-color: #87badc;
            transition: width 0.2s ease;
            overflow: hidden;
            z-index: 1000;
        }

        .sidebar.expanded {
            width: 300px;
        }

        .hamburger {
            cursor: pointer;
            padding: 15px;
        }

        .hamburger span {
            display: block;
            width: 30px;
            height: 3px;
            margin-bottom: 5px;
            position: relative;
            background: #333;
            border-radius: 3px;
            z-index: 1;
            transform-origin: 4px 0px;
            transition: transform 0.5s cubic-bezier(0.77,0.2,0.05,1.0), 
            background 0.5s cubic-bezier(0.77,0.2,0.05,1.0),
            opacity 0.55s ease;
        }

        .sidebar-content {
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin: 5px;
        }

        .sidebar.expanded .sidebar-content {
            opacity: 1;
        }

        .sidebar button {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
                background-color: #3498db;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                transition: background-color 0.3s;
            }

        .sidebar button:hover:not(.active) {
            background-color: #2980b9;
        }

        .sidebar button.active {
            background-color: #2ecc71;
            cursor: default;
        }

        #systemPrompt {
            width: 100%;
            resize: vertical;
            margin-top: 10px;
            padding-top: 10px;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
            color: #333;
            margin: 0;
            margin-left: 50px;
        }

        body.sidebar-expanded {
            margin-left: 300px;
        }

        h1 {
            margin-bottom: 30px;
            color: #2c3e50;
        }

        .input-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1200px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group label {
            font-weight: bold;
            color: #2c3e50;
        }

        .input-group input {
            width: 60px;
            padding: 5px;
            border: 1px solid #3498db;
            border-radius: 5px;
            font-size: 16px;
        }

        .button-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px;
            margin-bottom: 20px;}

        .button-group {
            display: flex;
            gap: 10px;
        }

        .container {
            display: flex;
            width: 100%;
            max-width: 1280px;
            gap: 20px;
        }

        .panel {
            display: flex;
            flex-direction: column;
        }

        .panel:first-child {
            flex: 2;
        }

        .panel:last-child {
            flex: 3;
        }

        .panel-header {
            background-color: #3498db;
            color: white;
            padding: 10px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
        }

        #transcription, #answers {
            height: 500px;
            border: 1px solid #ccc;
            border-top: none;
            padding: 10px;
            margin-bottom: 20px;
            white-space: pre-wrap;
            overflow-y: auto;
            background-color: white;
            border-radius: 0 0 5px 5px;
        }

        #answers {
            height: 500px;
            border: 1px solid #ccc;
            border-top: none;
            padding: 10px 20px;
            margin-bottom: 20px;
            white-space: pre-wrap;
            overflow-y: auto;
            background-color: white;
            border-radius: 0 0 5px 5px;
            line-height: 1.4;
            font-family: Arial, sans-serif;
            font-size: 17px;
        }

        #answers ul, #answers ol {
            margin: 0.17em 0;
            padding-left: 1.2em;
        }

        #answers li, #answers p, #answers h1, #answers h2, #answers h3, #answers h4, #answers h5, #answers h6 {
            margin-bottom: 0.17em;
        }

        #answers li > ul, #answers li > ol, #answers h3 > ul, #answers ul > h3 #answers p > ul #answers ul > p {
            margin-top: 0.11em;
            margin-bottom: 0.11em;
        }

        #answers code {
            background-color: #f0f0f0;
            padding: 1px 3px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }

        #answers pre {
            background-color: #f0f0f0;
            padding: 0.5em;
            border-radius: 3px;
            overflow-x: auto;
            margin: 0.3em 0;
        }

        #answers blockquote {
            border-left: 3px solid #ccc;
            padding-left: 0.5em;
            margin: 0.3em 0;
            color: #666;
        }

        .answer-popup {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .popup-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-height: 80%;
            overflow-y: auto;
            line-height: 1.4;
            font-family: Arial, sans-serif;
            font-size: 17px;
        }

        .popup-content ul, .popup-content ol {
            margin: 0.17em 0;
            padding-left: 1.2em;
        }

        .popup-content li, .popup-content p, .popup-content h1, .popup-content h2, .popup-content h3, .popup-content h4, .popup-content h5, .popup-content h6 {
            margin-bottom: 0.17em;
        }

        .popup-content li > ul, .popup-content li > ol, .popup-content h3 > ul, .popup-content ul > h3 .popup-content p > ul .popup-content ul > p{
            margin-top: 0.11em;
            margin-bottom: 0.11em;
        }

        .popup-content code {
            background-color: #f0f0f0;
            padding: 1px 3px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .popup-content pre {
            background-color: #f0f0f0;
            padding: 0.5em;
            border-radius: 3px;
            overflow-x: auto;
            margin: 0.3em 0;
        }

        .popup-content blockquote {
            border-left: 3px solid #ccc;
            padding-left: 0.5em;
            margin: 0.3em 0;
            color: #666;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #27ae60;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        #clearBtn {
            background-color: #e74c3c;
        }

        #clearBtn:hover {
            background-color: #c0392b;
        }

        .answers-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .answers-group .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .answers-group .input-group input {
            width: 40px;
            padding: 5px;
            border: 1px solid #3498db;
            border-radius: 5px;
            font-size: 16px;
        }

        #spinner {
            margin-left: 10px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .button-clicked {
            animation: buttonClick 0.3s ease;
            background-color: #1e8449; /* Darker green color when clicked */
        }

        #getAnswersBtn {
            background-color: #27ae60;
        }

        #getAnswersBtn:hover {
            background-color: #60bf88;
        }

        #getAnswersBtn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        #downloadBtn {
            background-color: #3498db;
        }

        #downloadBtn:hover {
            background-color: #2980b9;
        }

        #startBtn.resume {
            background-color: #f39c12;
        }

        #startBtn.resume:hover {
            background-color: #d35400;
        }

        .transcription-message {
            padding: 3px 10px;
            margin-bottom: 3px;
            border-radius: 2px;
            /* background-color: #f8f8f6; */
        }

        .transcription-message:last-child {
            margin-bottom: 0;
        }

        .transcription-message.editing {
            background-color: #e8f0fe; /* Light blue background for editing mode */
        }

        .transcription-message input {
            width: 100%;
            border: none;
            background-color: transparent;
            font-family: inherit;
            font-size: inherit;
        }

        .selected-message {
            background-color: #7bbdc7; /* Light background for selected messages */
        }

        .MathJax {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
        }

    </style>
</head>
<body>
    <div class="sidebar">
        <div class="hamburger">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="sidebar-content">
            <button id="serverModeBtn" class="active">Backend Side Transcription</button>
            <button id="clientModeBtn">Frontend Side Transcription</button>
            <label for="systemPrompt">System Prompt (Shift + Enter for new line):</label>
            <textarea id="systemPrompt" rows="25"></textarea>
        </div>
    </div>
    <h1 id="modeHeading">Backend Side (Mic + Speaker) Transcription</h1>
    <div class="input-container">
        <div class="input-group">
            <label for="openaiKey">OpenAI Key:</label>
            <input type="password" id="openaiKey">
        </div>
        <div class="input-group">
            <label for="lengthInSec" title="Transcribe these many seconds of audio at once">Audio Chunk Length:</label>
            <input type="number" id="lengthInSec" min="1" max="30" value="7">
        </div>
    </div>
    <div class="button-container">
        <div class="button-group">
            <button id="startBtn">Start</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="downloadBtn">Download Transcription</button>
            <button id="clearBtn">Clear</button>
        </div>
        <div class="answers-group">
            <div class="input-group">
                <label for="kAnswerHistory" title="Previous Que-Ans messages history to use as context">Prev Ans Context:</label>
                <input type="number" id="kAnswerHistory" min="0" max="5" value="0" title="Previous Que-Ans messages history to use as context">
            </div>
            <button id="getAnswersBtn">Get Answers</button>
            <div id="spinner" class="spinner" style="display: none;"></div>
        </div>
    </div>
    <div class="container">
        <div class="panel">
            <div class="panel-header">Transcription</div>
            <div id="transcription"></div>
        </div>
        <div class="panel">
            <div class="panel-header">Answers (Click on the text below to open popup)</div>
            <div id="answers"></div>
        </div>
    </div>
    <template id="message-template">
        <div class="transcription-message" data-timestamp="">
        </div>
    </template>
    <script>
        const transcriptionDiv = document.getElementById('transcription');
        const answersDiv = document.getElementById('answers');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const getAnswersBtn = document.getElementById('getAnswersBtn');
        const spinner = document.getElementById('spinner');
        const downloadBtn = document.getElementById('downloadBtn');
        const serverModeBtn = document.getElementById('serverModeBtn');
        const clientModeBtn = document.getElementById('clientModeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const sidebar = document.querySelector('.sidebar');
        const hamburger = document.querySelector('.hamburger');
        const sidebarContent = document.querySelector('.sidebar-content');
        const systemPrompt = document.getElementById('systemPrompt');
        const body = document.body;

        let socket;
        let audioSocket;
        let transcriptionHistory = [];
        let prevAnswersHistory = { prev_transcriptions: [], prev_answers: [] };
        let isResuming = false;
        let mediaRecorder;
        let audioChunks = [];
        let isClientMode = false;
        let numSpeakers = 1; // Deprecated Functionality
        let openaiLogin = false;
        let lastDisplayedIndex = -1;
        let lastAnsweredIndex = -1; // Initialize to -1, meaning no messages have been answered yet
        let lastSelectedIndex = null;
        let answerPopup;
        let popupContent;

        async function loadConfig() {
            const response = await fetch('/base-config');
            const config = await response.json();
            
            // Set audio settings
            document.getElementById('lengthInSec').value = config.audio.length_in_sec;
            document.getElementById('systemPrompt').value = config.llm.system_prompt;
            document.getElementById('kAnswerHistory').value = config.llm.k_answer_history
        }

        window.addEventListener('DOMContentLoaded', loadConfig); // Load the config

        hamburger.addEventListener('click', () => {
            sidebar.classList.toggle('expanded');
            body.classList.toggle('sidebar-expanded');
            if (sidebar.classList.contains('expanded')) {
                setTimeout(() => {
                    sidebarContent.style.display = 'block';
                }, 150);
            } else {
                sidebarContent.style.display = 'none';
            }
        });

        systemPrompt.addEventListener('blur', updateSystemPrompt);
        systemPrompt.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                updateSystemPrompt();
            }
        });

        async function updateSystemPrompt() {
            const newPrompt = systemPrompt.value;
            try {
                const response = await fetch('/update_system_prompt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ system_prompt: newPrompt }),
                });
                if (!response.ok) {
                    throw new Error('Failed to update system prompt');
                }
                console.log('System prompt updated successfully');
            } catch (error) {
                console.error('Error updating system prompt:', error);
            }
        }

        document.getElementById('openaiKey').addEventListener('change', async (e) => {
            const apiKey = e.target.value;
            try {
                const response = await fetch('/openai-login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ api_key: apiKey }),
                });
                
                if (response.ok) {
                    openaiLogin = true;
                    getAnswersBtn.disabled = false;
                } else {
                    const errorData = await response.json();
                    throw new Error(errorData.detail);
                }
            } catch (error) {
                openaiLogin = false;
                getAnswersBtn.disabled = true;
                alert(`OpenAI login failed: ${error.message}`);
            }
            updateGetAnswersButton();
        });

        document.getElementById('lengthInSec').addEventListener('change', async (e) => {
            const lengthInSec = parseInt(e.target.value);
            try {
                const response = await fetch('/update_length_in_sec', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ lengthInSec }),
                });
                if (!response.ok) {
                    throw new Error('Failed to update length in seconds');
                }
            } catch (error) {
                console.error('Error updating length in seconds:', error);
            }
        });


        downloadBtn.addEventListener('click', () => {
            const transcriptionJSON = JSON.stringify(transcriptionHistory, null, 2);
            const blob = new Blob([transcriptionJSON], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'transcription_history.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        clearBtn.addEventListener('click', () => {
            if (confirm("Are you sure you want to clear all history? This action cannot be undone.")) {
                // Clear transcription history
                transcriptionHistory = [];
                
                // Clear transcription panel
                transcriptionDiv.innerHTML = '';
                
                // Clear answers panel
                answersDiv.innerHTML = '';
                
                // Reset related variables
                lastDisplayedIndex = -1;
                lastAnsweredIndex = -1;
                
                lastSelectedIndex = null;
                
                console.log('History cleared');
            }
        });

        function connectWebSocket() {
            socket = new WebSocket('ws://' + window.location.host + '/ws');
            socket.onopen = function(event) {
                console.log("WebSocket connection opened");
            };
            socket.onmessage = function(event) {
                const timestamp = new Date().toLocaleTimeString();
                const newTranscription = `${timestamp}: ${event.data}`;
                transcriptionHistory.push(newTranscription);
                updateTranscriptionDisplay();
            };
            socket.onclose = function(event) {
                console.log("WebSocket connection closed");
            };
            socket.onerror = function(error) {
                console.error("WebSocket error:", error);
            };
        }

        function toggleMessageSelection(element, event) {
            const currentIndex = parseInt(element.getAttribute('data-index'));

            if (event.shiftKey && lastSelectedIndex !== null) {
                // Select range
                const start = Math.min(lastSelectedIndex, currentIndex);
                const end = Math.max(lastSelectedIndex, currentIndex);
                selectMessageRange(start, end);
            } else {
                // Toggle single message
                element.classList.toggle('selected-message');
                lastSelectedIndex = element.classList.contains('selected-message') ? currentIndex : null;
            }
        }

        function selectMessageRange(start, end) {
            const messages = transcriptionDiv.querySelectorAll('.transcription-message');
            messages.forEach(msg => {
                const index = parseInt(msg.getAttribute('data-index'));
                if (index >= start && index <= end) {
                    msg.classList.add('selected-message');
                }
            });
            lastSelectedIndex = end;
        }

        function getSelectedMessages() {
            const selectedElements = transcriptionDiv.querySelectorAll('.selected-message');
            return Array.from(selectedElements)
                .map(el => ({
                    index: parseInt(el.getAttribute('data-index')),
                    text: el.textContent
                }))
                .sort((a, b) => a.index - b.index)
                .map(item => item.text);
        }

        function getRecentTranscriptions() {
            const sixtySecondsAgo = Date.now() - 60000; // 60 seconds in milliseconds
            const recentMessages = transcriptionHistory.filter(msg => {
                const msgTime = new Date(msg.split(': ')[0]).getTime();
                return msgTime > sixtySecondsAgo;
            });

            // If we have less than 15 messages in the last 60 seconds,
            // get the last 15 messages from the entire history
            if (recentMessages.length < 15) {
                return transcriptionHistory.slice(-15);
            }

            return recentMessages;
        }

        function updateTranscriptionDisplay() {
            // Filter out empty or whitespace-only transcriptions and those with length < 6
            const filteredTranscription = transcriptionHistory.filter(t => {
                // Extract the actual transcription text after the timestamp
                const transcriptionText = t.split(': ').slice(1).join(': ').trim();
                return transcriptionText.length >= 6;
            });
            
            // Create a document fragment to hold new messages
            const fragment = document.createDocumentFragment();
            
            // Only create elements for new messages
            for (let i = lastDisplayedIndex + 1; i < filteredTranscription.length; i++) {
                const t = filteredTranscription[i];
                const messageElement = document.createElement('div');
                messageElement.className = 'transcription-message';
                messageElement.setAttribute('data-index', i);
                messageElement.textContent = t;
                messageElement.addEventListener('click', (event) => toggleMessageSelection(messageElement, event));
                messageElement.addEventListener('dblclick', (e) => startEditing(e, messageElement, i));
                fragment.appendChild(messageElement);
            }
            
            // Append only new messages
            transcriptionDiv.appendChild(fragment);

            // Update the last displayed index
            lastDisplayedIndex = filteredTranscription.length - 1;

            // Scroll to the bottom only if we're not editing or selecting
            const editingOrSelectedElement = document.querySelector('.editing, .selected-message');
            if (!editingOrSelectedElement) {
                transcriptionDiv.scrollTop = transcriptionDiv.scrollHeight;
            }
        }


        function startEditing(event, element, index) {
            event.stopPropagation();
            if (element.classList.contains('editing')) return;

            const fullText = element.textContent;
            const [timestamp, ...contentParts] = fullText.split(': ');
            const content = contentParts.join(': '); // Rejoin in case there were colons in the content

            element.classList.add('editing');
            element.setAttribute('data-original-timestamp', timestamp);
            element.style.backgroundColor = '#ffffd0';
            element.contentEditable = true;
            
            // Only make the content part editable
            element.textContent = content;
            
            element.focus();

            // Place cursor at the end of the content
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(element);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);

            element.addEventListener('blur', () => finishEditing(element, index));
            element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing(element, index);
                }
            });
        }
   
        function finishEditing(element, index) {
            const newText = element.textContent;
            let originalTimestamp = element.getAttribute('data-original-timestamp');
            
            // If there's no original timestamp, extract it from the current text
            if (!originalTimestamp) {
                const parts = transcriptionHistory[index].split(': ');
                originalTimestamp = parts[0];
            }

            element.classList.remove('editing');
            element.style.backgroundColor = '';
            element.contentEditable = false;

            // Update the transcription history, ensuring only one timestamp
            transcriptionHistory[index] = `${originalTimestamp}: ${newText.replace(/^[\d:APM\s]+:\s*/, '')}`;

            // Update the element's text content
            element.textContent = transcriptionHistory[index];

            // Remove data attribute
            element.removeAttribute('data-original-timestamp');

            // Remove event listeners
            element.removeEventListener('blur', () => finishEditing(element, index));
            element.removeEventListener('keydown', () => {});
        }

                
        function startRecording() {
            chunksSent = 0;
            
            websocket = new WebSocket('ws://localhost:8000/audio-stream');
            
            websocket.onopen = () => {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        audioContext = new AudioContext();
                        const source = audioContext.createMediaStreamSource(stream);
                        processor = audioContext.createScriptProcessor(16384, 1, 1);

                        source.connect(processor);
                        processor.connect(audioContext.destination);

                        let sampleRate = audioContext.sampleRate;
                        let resampleRatio = 16000 / sampleRate;

                        processor.onaudioprocess = function(e) {
                            let inputData = e.inputBuffer.getChannelData(0);
                            let resampledBuffer = new Float32Array(Math.round(inputData.length * resampleRatio));
                            
                            for (let i = 0; i < resampledBuffer.length; i++) {
                                resampledBuffer[i] = inputData[Math.floor(i / resampleRatio)];
                            }

                            let int16Array = new Int16Array(resampledBuffer.length);
                            for (let i = 0; i < resampledBuffer.length; i++) {
                                int16Array[i] = Math.max(-32768, Math.min(32767, Math.round(resampledBuffer[i] * 32767)));
                            }

                            websocket.send(int16Array.buffer);
                            chunksSent++;
                        };
                    })
                    .catch(err => {
                        showError('Error accessing microphone: ' + err.message);
                        console.error('Error accessing microphone:', err);
                    });
            };

            websocket.onmessage = event => {
                console.log('Received message:', event.data);
                if (event.data === "Transcription complete.") {
                    // Handle completion if needed
                } else {
                    const now = new Date();
                    const timeString = now.toLocaleTimeString();
                    
                    // Only add transcriptions that have meaningful content
                    const transcriptionText = event.data.trim();
                    if (transcriptionText.length >= 4) {
                        const newText = `${timeString}: ${transcriptionText}`;
                        
                        // Update transcription history
                        transcriptionHistory.push(newText);
                        
                        // Update the display
                        updateTranscriptionDisplay();
                    }
                }
            };

            websocket.onerror = error => {
                showError('WebSocket error: ' + error.message);
                console.error('WebSocket error:', error);
            };

        websocket.onclose = () => {
        };

        }

        function stopRecording() {
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.close();
            }
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }
        

            
        function connectAudioWebSocket() {
            audioSocket = new WebSocket('ws://' + window.location.host + '/audio-stream');
            audioSocket.binaryType = 'arraybuffer';
            audioSocket.onopen = function(event) {
                console.log("Audio WebSocket connection opened");
            };
            audioSocket.onclose = function(event) {
                console.log("Audio WebSocket connection closed");
            };
            audioSocket.onerror = function(error) {
                console.error("Audio WebSocket error:", error);
            };
        }


        startBtn.addEventListener('click', async () => {
            const endpoint = isClientMode ? 
                (isResuming ? '/resume-client' : '/start-client') : 
                (isResuming ? '/resume' : '/start');

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({numSpeakers }),
            });

            if (response.ok) {
                connectWebSocket();
                if (isClientMode) {
                    connectAudioWebSocket();
                    await startRecording();
                }
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                // Only clear history if it's a new session, regardless of mode
                if (!isResuming) {
                    transcriptionHistory = [];
                    updateTranscriptionDisplay();
                }
                
                startBtn.textContent = 'Start';
                startBtn.classList.remove('resume');
                isResuming = false;
            }
        });

        stopBtn.addEventListener('click', async () => {
            const endpoint = isClientMode ? '/stop-client' : '/stop';
            const response = await fetch(endpoint, { method: 'POST' });
            if (response.ok) {
                if (socket) {
                    socket.close();
                }
                if (isClientMode) {
                    if (audioSocket) {
                        audioSocket.close();
                    }
                    stopRecording();
                }
                startBtn.disabled = false;
                stopBtn.disabled = true;
                startBtn.textContent = 'Resume';
                startBtn.classList.add('resume');
                isResuming = true;
            }
        });

        function processEquations(text) {
            // Replace [equation] with $$equation$$
            return text.replace(/\[([\s\S]*?)\]/g, (match, p1) => `$$${p1}$$`);
        }

        getAnswersBtn.addEventListener('click', async () => {
            spinner.style.display = 'inline-block';
            getAnswersBtn.disabled = true;

            let selectedMessages = getSelectedMessages();
            let messagesToSend;

            if (selectedMessages.length === 0) {
                // If no messages are selected, send all messages since the last answered index
                messagesToSend = transcriptionHistory.slice(lastAnsweredIndex + 1);
            } else {
                messagesToSend = selectedMessages;
            }
            
            if (messagesToSend.length === 0) {
                alert("No new transcriptions available.");
                spinner.style.display = 'none';
                getAnswersBtn.disabled = false;
                return;
            }

            const kAnswerHistory = parseInt(document.getElementById('kAnswerHistory').value);

            try {
                const response = await fetch('/get_answers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        transcription: messagesToSend,
                        previous_answers_history: prevAnswersHistory,
                        k_answer_history: kAnswerHistory
                    }),
                });

                if (response.ok) {
                    const data = await response.json();
                    let markdown = data.markdown;
                    
                    // Process equations
                    markdown = processEquations(markdown);
                    
                    // Convert Markdown to HTML
                    let htmlAnswer = marked.parse(markdown);
                    answersDiv.innerHTML = htmlAnswer;
                    
                    // Update prevAnswersHistory
                    prevAnswersHistory.prev_transcriptions.push(messagesToSend.join('\n'));
                    prevAnswersHistory.prev_answers.push(markdown);


                    // Update lastAnsweredIndex
                    lastAnsweredIndex = transcriptionHistory.indexOf(messagesToSend[messagesToSend.length - 1]);

                    // Scroll to the top of the answer panel
                    answersDiv.scrollTop = 0;
                    
                    // Tell MathJax to render the math
                    MathJax.typesetPromise([answersDiv]).then(() => {
                        // MathJax rendering is complete
                    });

                    // Clear all selections
                    clearAllSelections();
                } else {
                    console.error('Error fetching answers');
                }
            } catch (error) {
                console.error('Error:', error);
            } finally {
                spinner.style.display = 'none';
                getAnswersBtn.disabled = false;
            }
        });

        function clearAllSelections() {
            const selectedMessages = transcriptionDiv.querySelectorAll('.selected-message');
            selectedMessages.forEach(msg => msg.classList.remove('selected-message'));
        }


        function updateGetAnswersButton() {
            getAnswersBtn.disabled = !openaiLogin;
            if (!openaiLogin) {
                getAnswersBtn.title = "Please enter a valid OpenAI API key to enable this button";
            } else {
                getAnswersBtn.title = "";
            }
        }

        
        serverModeBtn.addEventListener('click', () => {
            isClientMode = false;
            serverModeBtn.classList.add('active');
            clientModeBtn.classList.remove('active');
            resetUI();
        });

        clientModeBtn.addEventListener('click', () => {
            isClientMode = true;
            clientModeBtn.classList.add('active');
            serverModeBtn.classList.remove('active');
            resetUI();
        });

        function resetUI() {
            if (socket) {
                socket.close();
            }
            if (audioSocket) {
                audioSocket.close();
            }
            if (mediaRecorder) {
                mediaRecorder.stop();
            }
            startBtn.disabled = false;
            stopBtn.disabled = true;
            startBtn.textContent = 'Start';
            startBtn.classList.remove('resume');
            isResuming = false;
            transcriptionHistory = [];
            updateTranscriptionDisplay();
            answersDiv.innerHTML = '';
            updateModeUI(isClientMode);
        }

        const modeHeading = document.getElementById('modeHeading');

        function updateModeUI(isClientMode) {
                if (isClientMode) {
                    clientModeBtn.classList.add('active');
                    clientModeBtn.disabled = true;
                    serverModeBtn.classList.remove('active');
                    serverModeBtn.disabled = false;
                    modeHeading.textContent = "Frontend Side (Mic Only) Transcription";
                } else {
                    serverModeBtn.classList.add('active');
                    serverModeBtn.disabled = true;
                    clientModeBtn.classList.remove('active');
                    clientModeBtn.disabled = false;
                    modeHeading.textContent = "Backend Side (Mic + Speaker) Transcription";
                }
            }

        serverModeBtn.addEventListener('click', () => {
            isClientMode = false;
            updateModeUI(isClientMode);
            resetUI();
        });

        clientModeBtn.addEventListener('click', () => {
            isClientMode = true;
            updateModeUI(isClientMode);
            resetUI();
        });

        document.addEventListener('DOMContentLoaded', () => {
            answerPopup = document.getElementById('answerPopup');
            popupContent = document.getElementById('popupContent');
            answersDiv.addEventListener('click', showAnswerPopup);
            answerPopup.addEventListener('click', function(event) {
                if (event.target === answerPopup) {
                    answerPopup.style.display = 'none';
                }
            });
        });


        function showAnswerPopup() {
            if (answerPopup && popupContent) {
                popupContent.innerHTML = answersDiv.innerHTML;
                answerPopup.style.display = 'block';
                
                // Re-run MathJax on the popup content
                MathJax.typesetPromise([popupContent]).then(() => {
                    // MathJax rendering is complete
                });
            } else {
                console.error('Popup elements not found');
            }
        }
        // Initialize the UI
        updateGetAnswersButton();
        isClientMode = false;
        updateModeUI(isClientMode);
    </script>

    <div id="answerPopup" class="answer-popup">
        <div id="popupContent" class="popup-content"></div>
    </div>
</body>
</html>
